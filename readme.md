# ИНСТРУКЦИЯ ПО ЗАПУСКУ ПРОГРАММЫ
cfg.py - вы должны создать сами, я оставлю пример в каталоге (cfg_example.py)
Для Windows будет доступен исполняемый файл *.exe. Для MacOS/Windows (в случае необходимости) выполните следующие шаги для компиляции:

### НАЧАЛО ###
1. **Установите PyInstaller:**
Откройте терминал и выполните следующую команду:

'''
(bash)
pip install pyinstaller
'''

2. **Перейдите в каталог с вашими файлами:**
В терминале перейдите в каталог, содержащий ваши файлы main.py, cfg.py, и root_chromedriver.py.

'''
(bash)
cd /путь/к/вашему/каталогу
'''

3. **Скомпилируйте скрипт с PyInstaller:**
Выполните следующую команду:

'''
(bash)
pyinstaller --onefile main.py
Это создаст каталог dist в текущем местоположении, а внутри него будет исполняемый файл, имеющий то же имя, что и ваш скрипт, без расширения.
'''

'''
(bash)
cd dist
'''

4. **Запустите ваш исполняемый файл:**
Вы можете выполнить ваш исполняемый файл в терминале:

'''
(bash)
./main
'''

# (для MacOS) Есть вторая вариация - создание ".app" файла:

'''
(bash)
pyinstaller --onefile --windowed main.py
Затем в каталоге dist появится .app файл, подобный .exe на Windows который можно запустить простым щелчком.
'''

### НАЧАЛО ###
## Настройка файла `cfg.py`

В файле `cfg.py` укажите PATH до OCR тессеракта. Если исполняемый файл не будет найден по указанному пути, программа отправит сообщение об ошибке на целевой адрес электронной почты. Ссылки для тессеракта как для Windows, так и для MacOS доступны в `cfg.py`.

## Процесс работы программы

В окне программы будут появляться объявления, полученные с сайта и сохраненные в CSV. В конце работы парсера будет назначено новое время.

## После работы программы

Total CSV файлы будут автоматически пополняться новыми объявлениями, содержащими всю необходимую информацию. Из истории можно будет взять айдишник и найти его в Total CSV, чтобы получить более подробные данные об объявлении. History CSV будет постоянно обновляться: спарсенные данные о цене и просмотрах будут сохраняться сверху, а ID объявлений будут группироваться для удобства чтения. Время в файлах будет отражать текущую дату и время (на момент парсинга).